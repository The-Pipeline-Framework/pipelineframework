package org.pipelineframework.processor.util;

import java.io.IOException;
import java.io.InputStream;
import java.io.StringWriter;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import javax.annotation.processing.ProcessingEnvironment;
import javax.tools.StandardLocation;

import org.pipelineframework.config.pipeline.PipelineYamlConfig;
import org.pipelineframework.config.pipeline.PipelineYamlConfigLoader;
import org.pipelineframework.config.pipeline.PipelineYamlConfigLocator;
import org.pipelineframework.config.pipeline.PipelineYamlStep;
import org.pipelineframework.processor.PipelineCompilationContext;
import org.pipelineframework.processor.ir.GenerationTarget;
import org.pipelineframework.processor.ir.PipelineStepModel;
import org.pipelineframework.processor.mapping.PipelineRuntimeMapping;
import org.pipelineframework.processor.mapping.PipelineRuntimeMappingResolution;
import org.pipelineframework.processor.mapping.PipelineRuntimeMappingResolver;

/**
 * Generates orchestrator client configuration properties based on the compiled pipeline model.
 */
public class OrchestratorClientPropertiesGenerator {

    private static final String RESOURCE_PATH = "META-INF/pipeline/orchestrator-clients.properties";

    private final ProcessingEnvironment processingEnv;

    /**
     * Creates a new OrchestratorClientPropertiesGenerator.
     *
     * @param processingEnv the processing environment for compiler utilities and messaging
     */
    public OrchestratorClientPropertiesGenerator(ProcessingEnvironment processingEnv) {
        this.processingEnv = processingEnv;
    }

    /**
     * Writes the orchestrator client configuration to META-INF/pipeline/orchestrator-clients.properties.
     *
     * @param ctx the compilation context
     * @throws IOException if writing the resource fails
     */
    public void writeClientProperties(PipelineCompilationContext ctx) throws IOException {
        if (!ctx.isOrchestratorGenerated()) {
            return;
        }
        if (ctx.isTransportModeLocal()) {
            return;
        }

        List<PipelineStepModel> models = ctx.getStepModels();
        if (models == null || models.isEmpty()) {
            return;
        }

        List<PipelineStepModel> clientModels = filterClientModels(models, ctx.getTransportMode());
        if (clientModels.isEmpty()) {
            return;
        }

        OrchestratorClientModuleMapping mapping = loadModuleMapping(ctx);
        List<PipelineStepModel> orderedBaseSteps = orderBaseSteps(ctx, clientModels);
        List<PipelineStepModel> sideEffects = clientModels.stream()
            .filter(PipelineStepModel::sideEffect)
            .toList();

        List<String> moduleOrder = resolveModuleOrder(orderedBaseSteps, sideEffects, mapping);
        mapping = mapping.withResolvedModules(moduleOrder);

        StringWriter writer = new StringWriter();
        writer.append("# Generated by pipeline annotation processing. Overrides can be provided in application.properties.\n");

        if (ctx.isTransportModeGrpc()) {
            renderGrpcClients(writer, orderedBaseSteps, sideEffects, mapping);
        } else {
            renderRestClients(writer, orderedBaseSteps, sideEffects, mapping);
        }

        javax.tools.FileObject resourceFile = processingEnv.getFiler()
            .createResource(StandardLocation.CLASS_OUTPUT, "", RESOURCE_PATH, (javax.lang.model.element.Element[]) null);
        try (var output = resourceFile.openWriter()) {
            output.write(writer.toString());
        }
    }

    /**
     * Selects pipeline step models that are enabled for client generation for the provided transport mode.
     *
     * @param models the candidate step models to filter
     * @param transportMode the transport mode used to determine the required client generation target
     * @return a list of models whose enabled targets include the generation target corresponding to the transport mode
     */
    private List<PipelineStepModel> filterClientModels(
        List<PipelineStepModel> models,
        org.pipelineframework.processor.ir.TransportMode transportMode
    ) {
        GenerationTarget target = switch (transportMode) {
            case REST -> GenerationTarget.REST_CLIENT_STEP;
            case LOCAL -> GenerationTarget.LOCAL_CLIENT_STEP;
            case GRPC -> GenerationTarget.CLIENT_STEP;
        };
        return models.stream()
            .filter(model -> model.enabledTargets().contains(target))
            .toList();
    }

    /**
     * Builds an OrchestratorClientModuleMapping from the project's application properties and, when available,
     * includes resolved runtime client overrides from the compilation context.
     *
     * If the context contains a PipelineRuntimeMapping, that mapping is resolved against the step models and
     * its client overrides are applied to the returned OrchestratorClientModuleMapping; otherwise the mapping
     * is created solely from the loaded application properties.
     *
     * @param ctx the current pipeline compilation context used to load properties, step models, and optional runtime mapping
     * @return an OrchestratorClientModuleMapping configured from application properties and any resolved client overrides
     */
    private OrchestratorClientModuleMapping loadModuleMapping(PipelineCompilationContext ctx) {
        Properties properties = new Properties();
        try {
            properties = loadApplicationProperties(ctx);
        } catch (IOException e) {
            processingEnv.getMessager().printMessage(javax.tools.Diagnostic.Kind.WARNING,
                "Failed to read application.properties for module mapping overrides: " + e.getMessage());
        }
        PipelineRuntimeMapping runtimeMapping = ctx.getRuntimeMapping();
        if (runtimeMapping == null) {
            return OrchestratorClientModuleMapping.fromProperties(properties, processingEnv);
        }
        PipelineRuntimeMappingResolution resolution = ctx.getRuntimeMappingResolution();
        if (resolution == null) {
            PipelineRuntimeMappingResolver resolver =
                new PipelineRuntimeMappingResolver(runtimeMapping, processingEnv);
            resolution = resolver.resolve(ctx.getStepModels());
            ctx.setRuntimeMappingResolution(resolution);
        }
        return OrchestratorClientModuleMapping.fromProperties(
            properties,
            processingEnv,
            resolution.clientOverrides(),
            Map.of() // TODO: add aspectOverrides to PipelineRuntimeMappingResolution and plumb through here.
        );
    }

    /**
     * Load application.properties from the project's source directories or, if not found there, from the annotation-processing source path.
     *
     * @param ctx the compilation context used to determine candidate base directories to search
     * @return a Properties object populated from the first application.properties found; an empty Properties if none is found
     * @throws IOException if an I/O error occurs while reading a filesystem application.properties file
     */
    private Properties loadApplicationProperties(PipelineCompilationContext ctx) throws IOException {
        Properties properties = new Properties();
        for (Path baseDir : getBaseDirectories(ctx)) {
            Path propertiesPath = baseDir.resolve("src/main/resources/application.properties");
            if (Files.exists(propertiesPath) && Files.isReadable(propertiesPath)) {
                try (InputStream input = Files.newInputStream(propertiesPath)) {
                    properties.load(input);
                    return properties;
                }
            }
        }

        try {
            var resource = processingEnv.getFiler()
                .getResource(StandardLocation.SOURCE_PATH, "", "application.properties");
            try (InputStream input = resource.openInputStream()) {
                properties.load(input);
            }
        } catch (Exception e) {
            // Ignore when the resource is not available.
        }

        return properties;
    }

    private Set<Path> getBaseDirectories(PipelineCompilationContext ctx) {
        Set<Path> baseDirs = new LinkedHashSet<>();
        if (ctx != null && ctx.getModuleDir() != null) {
            baseDirs.add(ctx.getModuleDir());
        }
        String multiModuleDir = System.getProperty("maven.multiModuleProjectDirectory");
        if (multiModuleDir != null && !multiModuleDir.isBlank()) {
            baseDirs.add(Paths.get(multiModuleDir));
        }
        baseDirs.add(Paths.get(System.getProperty("user.dir", ".")));
        return baseDirs;
    }

    private List<PipelineStepModel> orderBaseSteps(
        PipelineCompilationContext ctx,
        List<PipelineStepModel> models
    ) {
        List<PipelineStepModel> baseSteps = models.stream()
            .filter(model -> !model.sideEffect())
            .toList();
        PipelineYamlConfig config = loadPipelineConfig(ctx);
        if (config == null || config.steps() == null || config.steps().isEmpty()) {
            return baseSteps;
        }

        List<PipelineStepModel> remaining = new ArrayList<>(baseSteps);
        List<PipelineStepModel> ordered = new ArrayList<>();
        for (PipelineYamlStep step : config.steps()) {
            if (step == null || step.name() == null) {
                continue;
            }
            String token = toClassToken(step.name());
            if (token.isBlank()) {
                continue;
            }
            PipelineStepModel match = selectBestMatch(remaining, token);
            if (match != null) {
                ordered.add(match);
                remaining.remove(match);
            }
        }
        ordered.addAll(remaining);
        return ordered;
    }

    private PipelineYamlConfig loadPipelineConfig(PipelineCompilationContext ctx) {
        Optional<Path> configPath = resolvePipelineConfigPath(ctx);
        if (configPath.isEmpty()) {
            return null;
        }
        PipelineYamlConfigLoader loader = new PipelineYamlConfigLoader();
        return loader.load(configPath.get());
    }

    private Optional<Path> resolvePipelineConfigPath(PipelineCompilationContext ctx) {
        Map<String, String> options = processingEnv != null ? processingEnv.getOptions() : Map.of();
        String explicit = options.get("pipeline.config");
        if (explicit != null && !explicit.isBlank()) {
            Path explicitPath = Path.of(explicit.trim());
            if (!explicitPath.isAbsolute()) {
                if (ctx.getModuleDir() != null) {
                    explicitPath = ctx.getModuleDir().resolve(explicitPath).normalize();
                } else if (processingEnv != null) {
                    processingEnv.getMessager().printMessage(javax.tools.Diagnostic.Kind.WARNING,
                        "pipeline.config is relative but moduleDir is null: '" + explicit + "'");
                }
            }
            if (Files.exists(explicitPath) && Files.isReadable(explicitPath)) {
                return Optional.of(explicitPath);
            }
            if (processingEnv != null) {
                processingEnv.getMessager().printMessage(javax.tools.Diagnostic.Kind.WARNING,
                    "pipeline.config not found/readable at '" + explicitPath + "' (from '" + explicit +
                        "'); falling back to discovered pipeline.yaml");
            }
        }
        Path moduleDir = ctx.getModuleDir();
        if (moduleDir == null) {
            return Optional.empty();
        }
        PipelineYamlConfigLocator locator = new PipelineYamlConfigLocator();
        return locator.locate(moduleDir);
    }

    private PipelineStepModel selectBestMatch(List<PipelineStepModel> candidates, String token) {
        PipelineStepModel best = null;
        int bestLength = -1;
        for (PipelineStepModel candidate : candidates) {
            if (candidate == null) {
                continue;
            }
            String normalized = normalizeStepToken(candidate.serviceName());
            if (normalized.contains(token) && token.length() > bestLength) {
                best = candidate;
                bestLength = token.length();
            }
        }
        return best;
    }

    /**
     * Produce a normalized class token from a step implementation class name.
     *
     * @param className the fully-qualified or simple class name of the step implementation; may be null
     * @return the normalized class token derived from the simple class name with common suffixes removed (only alphanumeric characters); empty string if the input is null or yields no characters
     */
    private String normalizeStepToken(String className) {
        String simple = className == null ? "" : className;
        int lastDot = simple.lastIndexOf('.');
        if (lastDot != -1) {
            simple = simple.substring(lastDot + 1);
        }
        simple = simple.replaceAll("(Service|GrpcClientStep|RestClientStep|LocalClientStep)(_Subclass)?$", "");
        return toClassToken(simple);
    }

    private String toClassToken(String name) {
        if (name == null) {
            return "";
        }
        return name.replaceAll("[^A-Za-z0-9]", "");
    }

    private List<String> resolveModuleOrder(
        List<PipelineStepModel> baseSteps,
        List<PipelineStepModel> sideEffects,
        OrchestratorClientModuleMapping mapping
    ) {
        List<String> ordered = new ArrayList<>();
        for (PipelineStepModel model : baseSteps) {
            String moduleName = mapping.resolveModuleName(model);
            addModuleIfAbsent(ordered, moduleName);
        }
        for (PipelineStepModel model : sideEffects) {
            String moduleName = mapping.resolveModuleName(model);
            addModuleIfAbsent(ordered, moduleName);
        }
        return ordered;
    }

    private void addModuleIfAbsent(List<String> modules, String moduleName) {
        if (moduleName == null || moduleName.isBlank()) {
            return;
        }
        if (!modules.contains(moduleName)) {
            modules.add(moduleName);
        }
    }

    private void renderGrpcClients(
        StringWriter writer,
        List<PipelineStepModel> baseSteps,
        List<PipelineStepModel> sideEffects,
        OrchestratorClientModuleMapping mapping
    ) {
        List<PipelineStepModel> all = new ArrayList<>();
        all.addAll(baseSteps);
        all.addAll(sideEffects);

        for (PipelineStepModel model : all) {
            OrchestratorClientModuleMapping.ClientConfig client = mapping.clientConfig(model);
            if (client == null) {
                continue;
            }
            writer.append("\n# Talk to ").append(client.name()).append(" service\n");
            writer.append("quarkus.grpc.clients.").append(client.name()).append(".host=")
                .append(client.host()).append("\n");
            writer.append("quarkus.grpc.clients.").append(client.name()).append(".port=")
                .append(String.valueOf(client.port())).append("\n");
            writer.append("quarkus.grpc.clients.").append(client.name())
                .append(".use-quarkus-grpc-client=true\n");
            if (client.tlsConfigurationName() != null) {
                String tlsDefault = client.tlsConfigurationName();
                String tlsExpression = "${pipeline.client.tls-configuration-name:" + tlsDefault + "}";
                writer.append("quarkus.grpc.clients.").append(client.name())
                    .append(".tls-configuration-name=")
                    .append(tlsExpression).append("\n");
                writer.append("quarkus.grpc.clients.").append(client.name())
                    .append(".tls.enabled=true\n");
                writer.append("quarkus.grpc.clients.").append(client.name())
                    .append(".plain-text=false\n");
            }
        }
    }

    private void renderRestClients(
        StringWriter writer,
        List<PipelineStepModel> baseSteps,
        List<PipelineStepModel> sideEffects,
        OrchestratorClientModuleMapping mapping
    ) {
        List<PipelineStepModel> all = new ArrayList<>();
        all.addAll(baseSteps);
        all.addAll(sideEffects);

        for (PipelineStepModel model : all) {
            OrchestratorClientModuleMapping.ClientConfig client = mapping.clientConfig(model);
            if (client == null) {
                continue;
            }
            writer.append("\n# Talk to ").append(client.name()).append(" service\n");
            writer.append("quarkus.rest-client.").append(client.name()).append(".url=https://")
                .append(client.host()).append(":").append(String.valueOf(client.port())).append("\n");
            if (client.tlsConfigurationName() != null) {
                String tlsDefault = client.tlsConfigurationName();
                String tlsExpression = "${pipeline.client.tls-configuration-name:" + tlsDefault + "}";
                writer.append("quarkus.rest-client.").append(client.name())
                    .append(".tls-configuration-name=")
                    .append(tlsExpression).append("\n");
            }
        }
    }
}
