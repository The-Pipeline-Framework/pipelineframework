/*
 * Copyright (c) 2023-2026 Mariano Barcia
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package org.pipelineframework.transport.function;

import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Function;

import io.smallrye.mutiny.Multi;

/**
 * Local invoke adapter for N->M function transport flows.
 *
 * @param <I> input payload type
 * @param <O> output payload type
 */
public final class LocalManyToManyFunctionInvokeAdapter<I, O> implements FunctionInvokeAdapter<I, O> {
    private final Function<Multi<I>, Multi<O>> delegate;
    private final String outputPayloadModel;
    private final String outputPayloadModelVersion;

    /**
     * Creates a local invoke adapter.
     *
     * @param delegate delegate function
     * @param outputPayloadModel output model name
     * @param outputPayloadModelVersion output model version
     */
    public LocalManyToManyFunctionInvokeAdapter(
            Function<Multi<I>, Multi<O>> delegate,
            String outputPayloadModel,
            String outputPayloadModelVersion) {
        this.delegate = Objects.requireNonNull(delegate, "delegate must not be null");
        this.outputPayloadModel = normalizeOrDefault(outputPayloadModel, "unknown.output");
        this.outputPayloadModelVersion = normalizeOrDefault(outputPayloadModelVersion, "v1");
    }

    @Override
    public Multi<TraceEnvelope<O>> invokeManyToMany(Multi<TraceEnvelope<I>> input, FunctionTransportContext context) {
        Objects.requireNonNull(input, "input stream must not be null");
        Objects.requireNonNull(context, "context must not be null");

        Multi<I> payloadStream = input.onItem().transform(TraceEnvelope::payload);
        String traceId = normalizeOrDefault(context.requestId(),
            context.requestId() == null || context.requestId().isBlank() ? UUID.randomUUID().toString() : context.requestId());
        AtomicLong outputIndex = new AtomicLong(0);

        return delegate.apply(payloadStream)
            .onItem().transform(output -> {
                if (output == null) {
                    throw new NullPointerException("LocalManyToManyFunctionInvokeAdapter delegate emitted null output");
                }
                String envelopeId = UUID.randomUUID().toString();
                String idempotencyKey = resolveIdempotencyKey(context, traceId, envelopeId, outputIndex.getAndIncrement());
                return new TraceEnvelope<>(
                    traceId,
                    null, // spanId
                    envelopeId,
                    null, // previousItemRef
                    outputPayloadModel,
                    outputPayloadModelVersion,
                    idempotencyKey,
                    output,
                    null, // occurredAt (generated by TraceEnvelope)
                    Map.of());
            });
    }

    private String resolveIdempotencyKey(
            FunctionTransportContext context,
            String traceId,
            String envelopeId,
            long outputIndex) {
        if (context.idempotencyPolicy() == IdempotencyPolicy.EXPLICIT) {
            return context.explicitIdempotencyKey()
                .map(explicit -> explicit + ":" + outputIndex)
                .orElse(traceId + ":" + outputPayloadModel + ":" + envelopeId);
        }
        return traceId + ":" + outputPayloadModel + ":" + envelopeId;
    }

    private static String normalizeOrDefault(String value, String fallback) {
        if (value == null) {
            return fallback;
        }
        String trimmed = value.trim();
        return trimmed.isEmpty() ? fallback : trimmed;
    }
}
